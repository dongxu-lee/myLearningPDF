# MySQL海量数据存储与优化（上）学习笔记

### 代码及文档地址 

文档地址：

1. github文档地址：https://github.com/dongxu-lee/myLearningPDF/blob/main/MySQL_1.md

2. 语雀文档地址：https://www.yuque.com/bailihang-3fszp/bkgbrq/uavlrg

## 第一部分：MySQL架构原理

### 1.1 MySQL体系架构概述

MySQL Server架构体系从上至下分为网络连接层、服务层、存储引擎层、系统文件层

#### 一、网络连接层

- 客户端连接器：能和MySQL服务器建立连接的客户端

#### 二、服务层

- 连接池
- 系统管理和控制工具
- SQL接口
- 解析器
- 查询优化器
- 缓存

#### 三、存储引擎层

- MyISAM、InnoDB等

#### 四、系统文件层

- 系统文件、日志文件等
- 日志文件
  - 错误日志 Error log
    默认开启， show variables like '%log_error%'
  - 通用查询日志 general query log
    记录一般查询语句， show variables like '%general%'
  - 二进制日志 binary log
    记录了对MySQL的更改操作，不记录select操作。主要用于数据库恢复和主从复制。
  - 慢查询日志 Slow query log
    记录所有执行时间超时的查询SQL，默认10s。
    show variables like '%slow_query%';
- 配置文件
  用于存放MySQL所有的配置信息文件，比如my.cnf、my.ini等
- 数据文件

### 1.2 MySQL运行机制概述

（插入1.png）

### 1.3 MySQL运行机制

- ①建立连接，客户端与服务端“半双工”，可以双向通信，但某一时刻只能单向通信，不能同时双向。
- ②查询缓存。
- ③解析器：把SQL语句解析为解析树。
- ④查询优化器：根据解析树生成最有的执行计划。分为两类：静态优化（编译时优化）、动态优化（运行时优化）。
- ⑤查询执行引擎负责执行SQL语句：执行引擎根据API接口与底层存储实现交互，得到查询结果并返回。

### 1.4 InnoDB和MyISAM对比

- 事务和外键

  InnoDB支持事务和外键，具有安全性和完整性，适合大量Insertheupdate

  MyISAM不支持事务和外键，它提供高速存储和检索，适合大量select

- 锁机制

  InnoDB支持行级锁，锁定指定记录。基于索引来加锁。

  MyISAM支持表级锁，锁定整张表。

- 索引结构

  InnoDB使用聚集索引，索引和记录在一起存储，既缓存索引，也缓存记录。

  MyISAM使用非聚集索引，索引和记录分开。

- 并发处理能力

  MyISAM使用表锁，会导致写操作并发降低。

  InnoDB读写阻塞和隔离级别有关。

### 1.5 Undo Log

#### 1.5.1 Undo Log介绍

- 数据库事务开始之前，会把要修改的记录放到Undo日志里，当事务回滚时或数据库崩溃时，可以利用Undo日志，撤销未提交事务对数据库产生的影响。

#### 1.5.2 Undo Log作用

- 实现事务的原子性

  执行过程中，出现错误或用户执行rollback，MySQL利用Undo Log中的备份实现事务回滚。

- 实现多版本并发控制MVCC

  事务未提交之前，Undo Log保存了未提交之前的版本数据，Undo Log中的数据可作为数据旧版本快照供其他并发事务进行快照读。

### 1.6 Redo Log和Binlog

两阶段提交的两个日志

#### 1.6.1 Redo Log

- Redo Log是为了事务持久性而出现的产物。防止在发生故障的时间点，还有脏页没有写入磁盘。
- 写入机制：顺序循环，覆盖写

#### 1.6.2 Binlog

- 记录表结构变更以及数据修改的二进制记录，不记录select、update之类的操作

#### Redo Log和Binlog区别

- Redo Log是InnoDB特有，Binlog是mySQL Server自带功能。
- Redo Log属于物理日志，记录该数据页更新状态内容，Binlog是逻辑日志，记录更新过程。
- Redo Log是循环写，日志大小固定，Binlog是追加写，写完一个新增一个。
- Redo Log作为服务器宕机后数据自动恢复使用，Binlog作为主从复制和数据恢复使用。Binlog没有cash-safe能力。

## 第二部分 MySQL索引原理

索引设计的理论知识：二分查找法、Hash和B+Tree

### 2.1 二分查找法

它的优点是等值查询、范围查询优秀，缺点是更新数据、增删数据成本高。

### 2.2 Hash结构

适合等值查询。

InnoDB自适应哈希索引功能强大，当InnoDB注意到某些索引访问非常频繁时，会在内存基于B+Tree再创建一个哈希索引，能够快速定位索引页。

### 2.3 B+Tree结构

- 非叶子结点不存储data，只存储索引值，提高存储数量
- 叶子结点包含所有索引值和data数据
- 叶子结点用指针连接，提高区间的访问性能

### 2.4  索引分析与优化

#### 2.4.1 EXPLAIN

EXPLAIN可以对SELECT语句进行分析，并输出SELECT执行的详细信息

#### 2.4.2 回表查询

#### 2.4.3 覆盖索引

#### 2.4.4 最左前缀原则

#### 2.4.5 LIKE查询

##### 面试题：MySQL使用like查询，能使用索引吗？

答：可以使用，但like里的查询字符不能以%开头，否则不能使用索引。

#### 2.4.6 NULL查询

##### 面试题：如果MySQL表的某一列含有NULL，包含该列的索引是否有效？

答：可以有效，但最好设置为NOTNULL。

## 第三部分 MySQL事务和锁

### 3.1 ACID

原子性、一致性、隔离性、持久性

### 3.2 事务控制

#### 3.2.1 并发事务

脏读、不可重复读、幻读

#### 3.2.2 排队

#### 3.2.3 排它锁

#### 3.2.4 读写锁

读读并行，其他请款还是要加排它锁

#### 3.2.5 MVCC 多版本并发控制

目前MVCC只在RC和RR两种隔离级别下工作

在MVCC中，读操作分两种：快照读与当前读。

- 快照读：读取的是记录的快照版本（从undo Log里读的），不用加锁
- 当前读：读取的是最新版本，从数据库里读的，会加锁，保证其他事务不会修改这条记录

MVCC解决的是读读、读写、写读的并发处理，如果要进一步解决写写冲突，需要锁的配合：

- 乐观锁
- 悲观锁

### 3.3 事物隔离级别

读未提交、读已提交、可重复读、串行化

MySQL默认是RR级别

### 3.4 锁机制和实战

#### 3.4.1 锁分类

从操作粒度分：表级锁、行级锁、页级锁

- 表级锁：锁住整张表
- 行级锁：锁一行数据
- 页级锁：锁定相邻的一组记录，粒度介于表锁和行锁之间

从操作类型分：读锁、写锁

从操作性能分：乐观锁、悲观锁

#### 3.4.2 行锁原理

<B>InnoDB行锁是通过对索引数据页上的记录加锁实现的。</B>

主要算法：

- RecordLock锁（锁定单行记录）、
- GapLock锁（间隙锁，锁定索引记录的间隙，RR支持）、
- Next-keyLock锁（记录所和间隙锁结合，既锁数据，也锁间隙，RR支持）

在RR级别，InnoDB对于记录加锁行为都是先采用Next-key Lock，但当SQL操作含有唯一索引时，降级为RecordLock。

## 第四部分 MySQL集群架构

### 4.1 主从模式

主从复制三个步骤：

- 主库将数据库的变更操作记录到Binlog日志里
- 从库读取主库中的Binlog日志信息到从库的Relay Log中继日志中
- 从库读取中级日志的信息进行Relay，更新从库信息

主从的问题：

- 主库宕机后，数据可能丢失
- 从库只有哦一个SQL Thread，主库写压力大，复制很可能延时

解决方法：

- 半同步复制--解决数据丢失问题：主库接到从库的ACK后才进行事务提交
- 并行复制--解决从库复制延时问题：从库多线程

### 4.2 读写分离

适合的中间件：MySQL Proxy、MyCat、Shardingphere

### 4.3 双主模式

### 4.4 分库分表

#### 4.4.1 主键策略

- UUID
- COMB（UUID变种，解决了UUID无序问题）
- SNOWFLAKE
- 数据库ID
- Redis生成ID

### 4.5 分片

### 4.6 扩容









